/// <reference types="node" />
import type { DecodeOptions, GetPublicKeyOrSecret, Jwt, Secret, SignOptions, VerifyOptions } from 'jsonwebtoken';
declare type JwtPayload = string | Buffer | Record<string, any>;
/**
 *
 * @see{@link https://github.com/auth0/node-jsonwebtoken}
 */
export declare class JwtService {
    private jwtConfig;
    /**
     * Synchronously sign the given payload into a JSON Web Token string
     * payload - Payload to sign, could be an literal, buffer or string
     * secretOrPrivateKey - Either the secret for HMAC algorithms, or the PEM encoded private key for RSA and ECDSA.
     * [options] - Options for the signature
     * returns - The JSON Web Token string
     */
    signSync(payload: JwtPayload, options?: SignOptions): string;
    signSync(payload: JwtPayload, secretOrPrivateKey: Secret, options?: SignOptions): string;
    /**
     * Asynchronous sign the given payload into a JSON Web Token string
     * payload - Payload to sign, could be an literal, buffer or string
     * secretOrPrivateKey - Either the secret for HMAC algorithms, or the PEM encoded private key for RSA and ECDSA.
     * [options] - Options for the signature
     * returns - The JSON Web Token string
     */
    sign(payload: JwtPayload, options?: SignOptions): Promise<string>;
    sign(payload: JwtPayload, secretOrPrivateKey: Secret, options?: SignOptions): Promise<string>;
    /**
     * Synchronously verify given token using a secret or a public key to get a decoded token
     * token - JWT string to verify
     * secretOrPublicKey - Either the secret for HMAC algorithms, or the PEM encoded public key for RSA and ECDSA.
     * [options] - Options for the verification
     * returns - The decoded token.
     */
    verifySync(token: string, options: VerifyOptions & {
        complete: true;
    }): Jwt | string;
    verifySync(token: string, options: VerifyOptions): JwtPayload | string;
    verifySync(token: string, secretOrPublicKey: Secret, options?: VerifyOptions & {
        complete: true;
    }): Jwt | string;
    verifySync(token: string, secretOrPublicKey: Secret, options?: VerifyOptions): JwtPayload | string;
    /**
     * Asynchronous verify given token using a secret or a public key to get a decoded token
     * token - JWT string to verify
     * secretOrPublicKey - Either the secret for HMAC algorithms, or the PEM encoded public key for RSA and ECDSA.
     * [options] - Options for the verification
     * returns - The decoded token.
     */
    verify(token: string, options?: VerifyOptions & {
        complete: true;
    }): Promise<Jwt | string>;
    verify(token: string, options?: VerifyOptions): Promise<JwtPayload | string>;
    verify(token: string, secretOrPublicKey: Secret | GetPublicKeyOrSecret, options?: VerifyOptions & {
        complete: true;
    }): Promise<Jwt | string>;
    verify(token: string, secretOrPublicKey: Secret | GetPublicKeyOrSecret, options?: VerifyOptions): Promise<JwtPayload | string>;
    /**
     * Returns the decoded payload without verifying if the signature is valid.
     * token - JWT string to decode
     * [options] - Options for decoding
     * returns - The decoded Token
     */
    decode(token: string, options: DecodeOptions & {
        complete: true;
    }): null | Jwt;
    decode(token: string, options: DecodeOptions & {
        json: true;
    }): null | JwtPayload;
    decode(token: string, options?: DecodeOptions): null | JwtPayload | string;
    /**
     * alias decode method
     * @param token
     * @param options
     */
    decodeSync(token: string, options: DecodeOptions & {
        complete: true;
    }): null | Jwt;
    decodeSync(token: string, options: DecodeOptions & {
        json: true;
    }): null | JwtPayload;
    decodeSync(token: string, options?: DecodeOptions): null | JwtPayload | string;
}
export {};
//# sourceMappingURL=jwt.d.ts.map